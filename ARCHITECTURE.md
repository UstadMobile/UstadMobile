# Environment constraints:
* **Limited (or no) connectivity** - connectivity: may or may not be available, if connectivity is available, it may have limited bandwidth, high latency, and packet loss. Connectivity when available is often metered.
* **Low-end devices**: devices are often low memory (e.g 512MB - 1GB RAM on Android, 4GB on desktop PCs), with limited storage space (e.g. 8-16GB) - such as Android Go. Devices will often use an older version of the Android OS (e.g. second hand devices etc).
* **Limited number of / access to devices**: devices are more likely to be shared between students, family members etc.


# Architecture objectives:
* Provide the maximum functionality possible with the minimum connectivity requirement eg.
    * Able to run queries offline-first without requiring access to the backend to run any processing / analytics etc (eg. attendance reports, usage data, etc)
    * Able to run all functions on the mobile / desktop app offline-first without connectivity and sync when a connection is available (e.g. record attendance, syncs when connection available).
    * Able to sync between nearby devices (e.g. teacher device student device) without requiring an Internet connection
    *  Minimize Internet bandwidth used
* Maximize code re-usage between platforms: avoid rewriting business logic for different platforms eg. database queries used to run reports, validation logic on screens, etc.
* Provide a native UI on each platform that is as performant as possible, ensuring acceptable performance on low-end devices (especially Android).
* Integrate with platform level networking APIs (e.g. Bluetooth, Network Service Discovery, WorkManager on Android to sync when a connection is available without requiring user to open app, etc)
* Maximize developer productivity and make the project as simple to work with for newcomers as reasonably possible.

# Architecture decisions

* **Code sharing using [Kotlin Multiplatform](https://kotlinlang.org/docs/multiplatform.html)**. Kotlin Multiplatform (unlike other multiplatform solutions) is not all or nothing. It allows sharing core logic between platforms (Android, JVM, and JS) such as validation logic, SQL queries, ViewModels, and (because it is compiled to native code) can straightforwardly interoperate with native libraries. Native apps (e.g. on Android/desktop) can access the full platform network stack as needed to use Bluetooth APIs, wifi APIs, etc. Each platform can provide a native UI and native performance.
* **Database driven**: data (e.g. user details, progress, etc) is stored and updated on the local database on the Android / desktop app, then syncâ€™d when a connection is available.  The web version will make REST requests to/from the server directly. This makes offline-first development far more straightforward: each component simply calls functions to update the database and does not need to worry about the online/offline state or the sync itself.
    * Data is synced (to the server, potentially via a local device e.g. teacher device) using Door. [Door](https://www.github.com/UstadMobile/door) makes [Room](https://developer.android.com/training/data-storage/room) databases work on Kotlin Multiplatform (e.g. provides support to run the same queries on both the client and the backend). Door runs a selective sync to sync only the data select on any particular device. Data can be pulled (e.g. when accessing a particular screen) or pushed (e.g. when a user selects a course to be synced for offline use.
    * The web version runs an HTTP rest request directly to the backend server in lieu of the database calls.
* **Follow Android architecture recommendations** for [layered architecture](https://developer.android.com/topic/architecture/recommendations#layered-architecture), [UI layer](https://developer.android.com/topic/architecture/recommendations#ui-layer), [ViewModel](https://developer.android.com/topic/architecture/recommendations#viewmodel), [Models](https://developer.android.com/topic/architecture/recommendations#models).  Business logic is contained in a ViewModel which provides a Flow of UiState data (e.g. the entity/entities being displayed to the user, validation messages, etc). Events are passed to the ViewModel, which then updates the UiState. See [CODING-STYLE.md](CODING-STYLE.md).
* **Testing: unit, integration, end-to-end** it is critical for the app to work as expected for users without needing manual testing for all key functionality. Use [Maestro](https://maestro.dev) for Android end-to-end, [Cypress](https://cypress.io/) for the web/desktop.   

# Platform stacks

* **Backend HTTP server**: [KTOR HTTP](https://ktor.io) server. Database connection using JDBC (mostly using endpoints generated by Door) to PostgreSQL or SQLite. Can use any standard http server (e.g. Apache or Nginx) to provide a reverse proxy, certificate management, etc.
* **Android client**: Kotlin Android app using [Jetpack Compose UI](https://developer.android.com/jetpack/compose), Door/Room database and sync.
* **Web client**: React app written in Kotlin using Kotlin/JS, [kotlin-wrappers](https://github.com/JetBrains/kotlin-wrappers) for [React](https://react.dev) and [MUI user interface](https://mui.com/). Screens are built as functional React components and reuse the same ViewModel used on Android. See [app-react](app-react),
* **Desktop**: Combination of the backend http server and the web user interface in a webview via [WebViewKo](https://github.com/Winterreisender/webviewko). This provides an application that can work offline on a Windows or Linux PC.



